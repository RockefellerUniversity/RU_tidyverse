---
title: "20191009_gettingtidy"
author: "Matt Paul"
date: "10/9/2019"
output: 
  html_document:
    number_sections: TRUE
    theme: yeti
    highlight: tango
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# BRC intro

The BRC is:
Basic BRC plug.

# Introduction to Data Wrangling with Tidy
## A problem we face when dealing with data regularly.

Every dataset is different. Sometimes very different.

There are many ways to do things. Everyone has their favorite syntax. 

The issue:  
Many fundamental data processing functions exist in *Base R* and beyond. Sometimes they can be inconsistent or unnecessarily complex. The result is code that is confusing and doesn't flow i.e. nested functions

## What does it mean to be tidy?

Tidyverse is most importantly a philosophy for data analysis that more often then not makes wrangling data easier. The tidyverse community have built what they describe as an "opinionated" group of packages. These packages readily talk to one another. 

* More efficient code
* Easier to remember syntax
* Easier to read syntax

Their manifesto: https://cran.r-project.org/web/packages/tidyverse/vignettes/manifesto.html

## What does it actually mean to be tidy?

* A defined vision for coding style in R  
* A defined vision for data formats in R
* A defined vision for package design in R
* Unified set of community pushing in a cohesive direction
* Critical mass of people to influence the way the whole R community evolves

## What are the main tools in the tidyverse?

* readr – reading data into R
* dplyr – manipulating data
* tibble - working with tibbles
* tidyr – miscellaneous tools for tidying data
* ggplot2 – making pretty graphs
* stringr – working with strings
* purr - iterating over data
* forcats - working with factors

Other tools have now been made for the tidy community. This community also overlaps with bioconductor. But the packages above are the linchpins that hold it together. 

## What are we doing today

Workflow Image for working with data. 

# Lets get tidy!
## First step lets load in the data we are using today
```{r}
load(file='~/Documents/Box Sync/RU/Teaching/teaching/tidyR/my_tidy.Rdata')
```

## Are all data frames equal?
```{r}
head(df1)
head(df2)
head(df3a)
head(df3b)
```

## What is a tidy dataset?

A tidy dataset is a data frame (or table) for which the following are true:

* Each variable has its own column
* Each observation has its own row
* Each value has its own cell

Our first dataframe is tidy

## Why bother?

Consistent dataframe layouts help to ensure that all values are present and that relationships between data points are clear.

R is a vectorized programming language. R builds data frames from vectors, and R works best when its operation are vectorized. Tidy data utilizes of both of these aspects of R.

=> Precise and Fast

## Lets load in the tidyverse
```{r}
library(tidyverse)
```

# These tools have same logic

 -> insert graphic here
 https://github.com/trinker/tidyr_in_a_nutshell

# dplyr: A tool to access and manipulate data in a dataframe

## Select
Select allows you to make a vector or dataframe from a specific variable or variables
```{r}
# Select one variable (common_name)
select(df1, common_name)
# Select two variables (age_classbylength and common_name)
select(df1, age_classbylength, common_name)
# Select all but one variable (length_mm)
select(df1,-length_mm)
# Select all a range of contiguous varibles (common_name:length_mm)
select(df1, common_name:length_mm)
```

## Filter
Filter allows you to access observations based on specific criteria
```{r}
# Filter all observation where the variable common_name is Sockeye salmon
filter(df1, common_name == 'Sockeye salmon')
# Filter all observations where the variable common_name is either Sockeye salmon or Chinook Salmon
filter(df1, common_name %in% c('Sockeye salmon', 'Chinook salmon'))
# Filter all observations where the variable common_name ends with 'salmon'. To do this we use stringr function str_ends recognise strings that end with 'salmon'.
filter(df1, str_ends(common_name, 'salmon'))
# Filter all observations where the variable length_mm is greater than 200 or less than 120
filter(df1, length_mm > 200 | length_mm < 120)
```

## Arrange
Arrange sorts the dataframe based on a specific variable or variables
```{r}
# Arrange the data based on the variable length_mm
arrange(df1, length_mm)
# Arrange the data first based on the variable common_name, then secondly based on length_mm in a descending order.
arrange(df1, common_name, desc(length_mm))
```

## Mutate
Mutate creates a new variable based on some form of computation
```{r}
# A new variable is created based on the caluclation of the z-score of the variable IGF1_ng_ml using scale()
mutate(df1, scale(IGF1_ng_ml, center = TRUE, scale = TRUE))
# A new variable is created called IGFngml_zscore, based on the caluclation of the z-score of the variable IGF1_ng_ml using scale()
mutate(df1, IGFngml_zscore = scale(IGF1_ng_ml, center = TRUE, scale = TRUE))
```

## Summarize
Summarize applies aggregating or summary function to a group
```{r}
# First we define the common_name as a group. 
df1_byname <- group_by(df1, common_name)
# Summarise is used to count over the grouped common_names
summarise(df1_byname, count = n())
# Summarise is used to calculate mean IGF1_ng_ml over the grouped common_names
summarise(df1_byname, IGF1_ng_ml_ave = mean(IGF1_ng_ml, na.rm = T))
```

## Group
Grouping can also help ask questions with other functions
```{r}
# Filter obsevrations with the 2 smallest length_mm for each grouped common_names
filter(df1_byname, rank(length_mm) <= 2)

# Filter obsevrations with at least 5 for each grouped common_names
filter(df1_byname, n() > 5)

# A new variable is created using z-score within the grouped common_names
mutate(df1_byname, IGFngml_zscore = scale(IGF1_ng_ml, center = TRUE, scale = TRUE))

```

# Piping (%>%): A way to string together functions together
Piping allows you to pass the result from one expression directly into another.

 -> same graphic as before , but extend
 https://github.com/trinker/tidyr_in_a_nutshell

## Piping versus not piping
```{r}
# Without pipe
df1_byname <- group_by(df1, common_name)
summarise(df1_byname, IGF1_ng_ml_ave = mean(IGF1_ng_ml, na.rm=T))

# With pipe
group_by(df1, common_name) %>% summarise(IGF1_ng_ml_ave = mean(IGF1_ng_ml, na.rm=T))
```

## Building pipes together
```{r}
# (1) Group by common_name
# (2) Filter to all those that have length bigger then 200
# (3) Summarise is used to calculate mean IGF1_ng_ml over the grouped common_names for these larger fish
group_by(df1, common_name) %>% 
  filter(length_mm > 200) %>% 
  summarise(IGF1_ng_ml_ave = mean(IGF1_ng_ml, na.rm = T))

# (1) Create new variable that is discrete label depending on size of the fish
# (2) Group by common_name and size
# (3) Summarise is used to calculate mean IGF1_ng_ml over the grouped common_names and sizes
mutate(df1, size = if_else(length_mm > 200, 'big_fish', 'small_fish')) %>% 
  group_by(common_name, size) %>% 
  summarise(IGF1_ng_ml_ave = mean(IGF1_ng_ml, na.rm = T))

# (1) Create new variable that is discrete label depending on size of the fish
# (2) Group by common_name and size
# (3) Summarise is used to calculate mean IGF1_ng_ml over the grouped common_names and sizes
# (4) Filter out Coho and Sockeye salmon
mutate(df1, size = if_else(length_mm > 200, 'big_fish', 'small_fish')) %>% 
  group_by(common_name, size) %>% 
  summarise(IGF1_ng_ml_ave = mean(IGF1_ng_ml, na.rm = T)) %>%
  filter(common_name != 'Coho salmon')  %>%
  filter(common_name !='Sockeye salmon')
```

## Say want to graph what is going on with these fish? age species. IGF per length. 
```{r, warning=F, message=F}

p <- mutate(df1,size=if_else(length_mm>200, 'big_fish', 'small_fish')) %>% 
  group_by(common_name, size) %>% 
  dplyr::summarize(IGF1_ng_ml_ave=mean(IGF1_ng_ml, na.rm=T)) %>% 
  filter(common_name!='Coho salmon')  %>% 
  filter(common_name!='Sockeye salmon') %>% 
  ggplot( aes(x = common_name, y = IGF1_ng_ml_ave, group = size, fill = size)) +
  geom_bar(stat = "identity", position = "dodge") + 
  theme(axis.text.x = element_text(angle = 90)) +
  scale_fill_brewer(palette = "Paired")

p
```

CHALLENGE
```{r}
# GET A SPECIFIC GROUP AND PLOT IT. 
```

ANSWER
```{r}
# GET A SPECIIFC GROUP AND PLOT IT. 
```


# Readr: Reading data into R
So we blasted through what being tidy can give you. 
Now lets tidy some data. First step is to read in data. 

ReadR:

* read_csv(): comma separated (CSV) files  
* read_tsv(): tab separated files  
* read_delim(): general delimited files  
* read_fwf(): fixed width files  
* read_table(): tabular files where columns are separated by white-space  
* read_log(): web log files   

## ReadR vs Base
```{r}
#Base gives you everything
untidy_counts_base <- read.csv("~/Documents/Box Sync/RU/Teaching/teaching/tidyR/dataset/hemato_rnaseq_counts.csv")
head(untidy_counts_base)

#ReadR gives you a tibble
untidy_counts <- read_csv("~/Documents/Box Sync/RU/Teaching/teaching/tidyR/dataset/hemato_rnaseq_counts.csv")
untidy_counts

#Tibbles carry and display extra information. While reading in it is easy to specify datatype. 
untidy_counts <- read_csv("~/Documents/Box Sync/RU/Teaching/teaching/tidyR/dataset/hemato_rnaseq_counts.csv", col_types = cols(
    ENTREZ = col_character(),
    CD34_1 = col_integer(),
    ORTHO_1 = col_integer(),
    CD34_2 = col_integer(),
    ORTHO_2 = col_integer()
  ))
untidy_counts

```

# Tibbles

## Subsetting tibbles
```{r}
#Can use the same way as base to interact with the tibble dataframe
untidy_counts[,1]
untidy_counts[1,]

#Can also not specify which dimension you pull from. This will default to grabbing the column
untidy_counts[1]

#All the prior outputs have been outputting another tibble. If double brackets are used a vector is returned 
untidy_counts[[1]]

#This is also the case if you use the dollar and colname to access a column
untidy_counts$ENTREZ
```

## Converting Tibbles - Back and Forth
```{r}
#Can convert base dataframes into tibbles
as_tibble(untidy_counts_base)

#Once it is a tibble it is straightforward to modify the datatype
untidy_counts_base <- as_tibble(untidy_counts_base) %>%
  mutate_at(vars(ENTREZ), as.character)
untidy_counts_base

#Some tools are not tibble friendly. Calling as.data.frame is sufficient to convert it back to a base data frame
as.data.frame(untidy_counts_base)
```

## Make your own tibble. Lets grab some metadata to do this. 
```{r, warning=FALSE, message=FALSE}
# Lets load in some packages
library(org.Hs.eg.db)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)

#Lets use the ENTREZ ID as a key
keys <- untidy_counts$ENTREZ

#We can use the ENTREZ ID to look up Gene Symbol
symbols <- select(org.Hs.eg.db, keys=keys,columns="SYMBOL", keytype="ENTREZID")

#We can use the ENTREZ ID to look up the chormosome the gene resides on
chrs <- select(TxDb.Hsapiens.UCSC.hg19.knownGene, keys=keys, columns="TXCHROM", keytype="GENEID")

#We can use the ENTREZ ID to get a list of genes with grange of their exons
geneExons <- exonsBy(TxDb.Hsapiens.UCSC.hg19.knownGene,by="gene")[keys]

#We will then use an apply to get the transcript length from each gene in the list. The transcript length is calculated by first flattening overalpping exons with reduce(), then calculating the length of each exon with width(), then summing upthe total exon length to get our transcript length. 
txsLength <- sapply(geneExons, function(x){ x %>% reduce() %>% width() %>% sum() })

# FInally we have all this metadata. Lets put it together into a tibble. 
counts_metadata <- tibble(ID=symbols$ENTREZID,SYMBOL=symbols$SYMBOL,CHR=chrs$TXCHROM,LENGTH=txsLength)
```

# Tidying data up
## What is wrong with this dataframe from a tidy viewpoint?

* Each variable has its own column
* Each observation has its own row
* Each value has its own cell

```{r}
untidy_counts
```

A single variable with multiple columns

## How do we get tidy? - Pivot tools (formerly known as gather/spread )
```{r}
#Pivot longer allows you to collapse variables single varibles that are spread over multiple columns
tidier_counts<-pivot_longer(untidy_counts, cols=c(-ENTREZ), names_to = c("Sample"), values_to = "counts")

#Pivot wider allows you to spread single variables over multiple columns   
pivot_wider(tidier_counts, names_from = c("Sample"), values_from = "counts")
```

## What next?
```{r}
tidier_counts
```

Multiple variables in a single column

## Dealing with multiple variables in a single column

How do we get tidy? - Cleaning up
```{r}
#Seperate allows you to break a strings in a vraible by a seperator. In this case the cell type and replicate number are broken by underscore
tidier_counts <- separate(tidier_counts, Sample, sep = "_", into=c("CellType","Rep"), remove=TRUE)
tidier_counts

#Unite can go the other way if you want to generate a key. We can use this to make sure we have a Key.
unite(tidier_counts, Sample, CellType, Rep, remove=FALSE)


#Remember you can always pipe eveyrthing together into a single expression
tidy_counts <- untidy_counts %>% 
  pivot_longer(cols = c(-ENTREZ), names_to = c("Sample"), values_to = "counts") %>% 
  separate(Sample, sep = "_", into = c("CellType","Rep"), remove=FALSE)
```

# Joining: We have two related data frames. Can we link them together?


## Data frames can be joined on a shared variable a.k.a. a key
You need a key. Often we want this to be unique i.e. ENTREZ ID. 
```{r}
tidy_counts
counts_metadata
inner_join(tidy_counts, counts_metadata, by = c("ENTREZ" = "ID"))
```

## There are many ways to join things

Inner Join 
* Keeps all observations in x and y with matching keys

Outer Join
* A left join keeps all observations in x and those in y with matching keys.
* A right join keeps all observations in y and those in x with matching keys. 
* A full join keeps all observations in x and y

## Example - I only want to look at expressed genes

```{r}
# In this pipe I group by gene, summarise the data based on the sum of counts, and filter for anything that has a count greater than 0. 
expressed_genes <- tidy_counts %>% 
  group_by(ENTREZ) %>% 
  summarise(count_total=sum(counts)) %>% 
  filter(count_total>0)

# Left join shows all genes as my full data frame tidy_counts is used as the backbone. Thefiltered expressed genes is secondary, and has missing values (unexpressed genes) whichare filled with NA
left_join(tidy_counts, expressed_genes, by = c("ENTREZ" = "ENTREZ")) %>% print(n=20)

# Right join shows only genes that survived filtering as it is using the second dataframe as the backbone for the new dataframe. 
tidy_counts_expressed <- right_join(tidy_counts,expressed_genes, by = c("ENTREZ" = "ENTREZ"))
tidy_counts_expressed  %>% print(n=20)
```

## Filtering joins. 
```{r}
#Semi join only keeps observations in x that are matched in y. y is only used as a reference and is not in output
semi_join(tidy_counts, expressed_genes)

#Anti join only keeps observations in x that are not matched in y. y is only used as a reference and is not in output
anti_join(tidy_counts, expressed_genes)

```

## Calculate CPMs and TPMs

Show diagram of the math

```{r, warning=FALSE, message=FALSE}

# Use Group to focus computation on each sample. Use mutate to make new variable that is the CPM
tidy_counts_expressed <- tidy_counts_expressed  %>% 
  group_by(Sample) %>% 
  mutate(CPM=(counts/sum(counts))*1000000)

# Join our tidy data to the metadata, then make new variable that is the TPM
tidy_counts_expressed <- tidy_counts_expressed %>% 
  inner_join(counts_metadata, by = c("ENTREZ" = "ID")) %>%  
  mutate(TPM=(counts/(LENGTH/1000))/(sum(counts)/1000000))

# Simple X-Y plot comparing TPM and CPM. 
p <- tidy_counts_expressed %>% 
  ggplot(aes(x=CPM, y=TPM, group = 1, text = paste("Gene: ", SYMBOL))) + 
  geom_point() + 
  scale_x_continuous(name="log2(CPM)",trans='log2') + 
  scale_y_continuous(name="log2(TPM)",trans='log2')
   

plotly::ggplotly(p)
```

# Readr again: Writing your lovely new tibble to file
```{r}
#A key difference compared to base is that it does not write out row names. Tibbles generally don't have rownames. 
#Theres a wide range of writing options. Can specify the delmiter directly or use a speicfic function
write_delim(tidy_counts_expressed, '~/Documents/Box Sync/RU/Teaching/teaching/tidyR/expressed_genes_output.csv', delim =',')

write_csv(tidy_counts_expressed, '~/Documents/Box Sync/RU/Teaching/teaching/tidyR/expressed_genes_output.csv')

```

## At this point we have covered or touched on the most essential facets of tidy

* ~~ggplot2 – making pretty graphs~~ 
* ~~readr – reading data into R~~  
* ~~dplyr – manipulating data~~  
* ~~tibble - working with tibbles~~  
* ~~tidyr – miscellaneous tools for tidying data~~
* purrr - iterating over data  
* stringr – working with strings  
* forcats - working with factors  

# purrr - Functional programming 

Applying functions to datasets  

Base people use for loops or apply  

Big advantage it handles nested dataframes and has standard outputs

## map - tidy way to iterate over a dataset 
```{r}
#Map is the tidy equivalent to apply. Here we take our untidy counts, trim of IDs, and then caluclate means for eaxh column. By default the output is a list
untidy_counts %>% 
  dplyr::select(-ENTREZ) %>% 
  map(mean)

#Same as the above line, but using map_dbl specifies the outputs is going to be a double
untidy_counts %>% 
  dplyr::select(-ENTREZ) %>% 
  map_dbl(mean)

#Summary also works in this context
tidy_counts %>% 
  dplyr::group_by(Sample) %>% 
  dplyr::summarize(mean_counts=mean(counts))

#This is an alternative method for doing this with an tidied frame
tidy_counts %>% 
  split(.$Sample) %>% 
  map_dbl(~mean(.$counts))

```

## Nest - simplifying your dataframe by making it more complex
```{r}

tidy_counts_nest <- tidy_counts_expressed %>% 
  dplyr::group_by(Sample) %>%
  nest()

tidy_counts_nest

tidy_counts_nest$data %>% is()

tidy_counts_nest$data[[1]]


tidy_counts_nest <- tidy_counts_nest %>% 
  mutate(my_model = map(data, ~lm(CPM ~ TPM, data = .)))

tidy_counts_nest

tidy_counts_nest$my_model %>% is()

tidy_counts_nest$my_model[[1]]


library(broom)
tidy_counts_nest <- tidy_counts_nest %>% 
  mutate(my_tidy_model = map(my_model, broom::tidy))

tidy_counts_nest

tidy_counts_nest$my_tidy_model[[1]]
```

## Unnest - Expand out dataframes
```{r}
tidy_counts_nest %>%
  unnest(my_tidy_model)

tidy_counts_nest %>%
  unnest(my_tidy_model) %>% 
  unnest(data)

```

# Stringr

If the data you are working with involves characters from data entry often there will be errors i.e. clinical study metadata or a hand-typed list of genes of interest. Tidying data also means fixing these problems. Stringr helps make this easy. 

* Access and manipulate Characters
* Deal with whitspace
* Pattern Recognition

Though stringr is pretty comprehensive and covers most of what you will need, there is a sister package called stringi with even more functionality. 

## Basic functions to interact with strings
Many overlapping functions with base for combining, subsetting, converting and finding strings

```{r}
brc <- c("Tom", "Ji-Dung", "Matt")
# Extract substrings from a range. Here the 1st to 3rd character
str_sub(brc, 1, 3)
# Extract substrings from a range. Here the 2nd to 2nd to last character
str_sub(brc, 2, -2)
# Assign values back to substrings. Here the 2nd to 2nd to last character is replaced with X.
str_sub(brc, 2, -2)<-'X'

```

## Stripping whitespace
```{r}
brc2 <- c("Tom  ", "  Ji  -Dung", "Matt   ")

#Trim whitespace from strings
brc2 <- str_trim(brc2)
brc2 

#Can add whitespace to strings to get consistent length. Here all are 10 characters
str_pad(brc2, width=10, side='left')

```

## Converting strings - Capitalization
```{r}
#Lets reuse our counts tibble. pull from dplyr can be used to grab a tibble column and make it into a vector
tidy_counts_expressed %>% 
  pull(SYMBOL) %>%
  head()

#Here we pull our gene symbols from our tibble into a vector, and then convert them into title style capitalization
tidy_counts_expressed %>% 
  pull(SYMBOL) %>% 
  str_to_title() %>% 
  head()

#String manipulation functions can be used on tibbles using mutate. Here we convert gene symbols to title style capitalization
tidy_counts_expressed %>% 
  mutate(SYMBOL = str_to_title(SYMBOL))

# Here we convert CHR annotation to capitals
tidy_counts_expressed %>% 
  mutate(CHR = str_to_upper(CHR))

```

## Finding patterns
```{R}
#Find patterns in different ways
#Detect gives a T/F whether the pattern 'salmon' is present in vector
df1 %>% 
  dplyr::pull(common_name) %>% 
  str_detect('salmon')

#Subset returns the match if the pattern 'salmon' is present in vector
df1 %>% 
  dplyr::pull(common_name) %>% 
  str_subset('salmon') 

#Ends is similar to detect as it gives gives a T/F whether the pattern 'salmon' is present in vector, but the pattern has to be at the end. 
df1 %>% 
  dplyr::pull(common_name) %>% 
  str_ends('salmon') 

df1 %>% 
  filter(str_ends(common_name,'salmon'))


#Count gives you the total number of times your pattern appears in each chracter in the vector
df1 %>% 
  dplyr::pull(common_name) %>% 
  str_count('salmon')

df1 %>% 
  dplyr::pull(common_name) %>% 
  str_count('o')

#Replace
df1 %>% 
  dplyr::pull(common_name) %>%
  str_replace_all('Steelhead','Steelhead trout' )

df1 %>% 
  mutate(common_name = str_replace_all(common_name,'Steelhead','Steelhead trout' ))

```

# forcats - Handling factors

Factors are a data type that R uses to handle fixed categorical variables that have a known set of possible values. 

Factors are ordered, allowing hierachy to be presevred in relatively simple vectors.

## Making a factor
```{r}

# anything not in factor will become an NA
# 
# 
# access levels
# 
# (short verse long gnnes?)
# 
# 
# 
# fct_count




```

## Changing the order
```{r}


```

## Other useful things.
```{r}

# fct_c to combine

```

fct_reorder(): Reordering a factor by another variable.
fct_infreq(): Reordering a factor by the frequency of values.
fct_relevel(): Changing the order of a factor by hand.
fct_lump(): Collapsing the least/most frequent values of a factor into “other”.


## Tidy beyond this workshop

Hadley Wickham (Chief Scientist at RStudio) is the driving force behind the tidyverse.  

Hadley wrote a paper about why he thinks tidy data is best: www.jstatsoft.org/v59/i10/paper.  

There is a lot of support for all things tidy at: https://www.tidyverse.org/


## Tidy packages to check out:

readxl: This package is very useful when you want to import Excel sheets in R
googledrive: Interact with your googledrive through R

lubridate and hms: Allow managin of calendar and time formats

magrittr:

broom: helps tidy up standard base function i.e. lm or t.test

tidymodels:



## Other Good Resources

GGplot here

tidy workbook


# BRC outro
```{r}

```







