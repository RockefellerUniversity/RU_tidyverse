---
title: "20191009_gettingtidy"
author: "Matt Paul"
date: "10/9/2019"
output: 
  html_document:
    number_sections: TRUE
    theme: yeti
    highlight: tango
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## BRC intro

The BRC is:
Basic BRC plug.

# Introduction to Data Wrangling with Tidy
## A problem we face when dealing with data regularly.

Every dataset is different. Sometimes very different.

There are many ways to do things. Everyone has their favorite syntax. 

The issue:  
Many fundamental data processing functions exist in *Base R* and beyond. Sometimes they can be inconsistent or unnecessarily complex. The result is code that is confusing and doesn't flow i.e. nested functions

## What does it mean to be tidy?

Tidyverse is most importantly a philosophy for data analysis that more often then not makes wrangling data easier. The tidyverse community have built what they describe as an "opinionated" group of packages. These packages readily talk to one another. 

* More efficient code
* Easier to remember syntax
* Easier to read syntax

## What does it actually mean to be tidy?

* A defined vision for coding style in R  
* A defined vision for data formats in R
* A defined vision for package design in R
* Unified set of community pushing in a cohesive direction
* Critical mass of poeple to influence the way the whole R commnity evolves

## What are the main tools in the tidyverse?

* readr – reading data into R
* dplyr – manipulating data
* tibble - working with tibbles
* tidyr – miscellaneous tools for tidying data
* ggplot2 – making pretty graphs
* stringr – working with strings
* purr - iterating over data
* forcats - working with factors

Other tools have now been made for the tidy community. This community also overlaps with bioconductor. But the packages above are the linchpins that hold it together. 

## What are we doing today

Workflow Image for working with data. 

# Lets get tidy!
## First step lets load in the data we are using today
```{r}
load(file='~/Documents/Box Sync/RU/Teaching/teaching/tidyR/my_tidy.Rdata')
```

## Are all data frames equal?
```{r}
head(df1)
head(df2)
head(df3a)
head(df3b)
```

## What is a tidy dataset?

A tidy dataset is a data frame (or table) for which the following are true:

* Each variable has its own column
* Each observation has its own row
* Each value has its own cell

Our first dataframe is tidy

## Why bother?

Consistent dataframe layouts help to ensure that all values are present and that relationships between data points are clear.

R is a vectorized programming language. R builds dataframes from vectotrs, and R works best when its operation are vectorized. Tidy data utilizes of both of these aspects of R.

=> Precise and Fast

## Lets load in the tidyverse
```{r}
library(tidyverse)
```

# These tools hav same logic

 -> insert graphic here
 https://github.com/trinker/tidyr_in_a_nutshell

# dplyr: A tool to access and manipulate data in a dataframe

## Select
Select allows you to make a vector or dataframe from a specific variable or variables
```{r}
# Select one variable (common_name)
select(df1, common_name)
# Select two variables (age_classbylength and common_name)
select(df1, age_classbylength, common_name)
# Select all but one variable (length_mm)
select(df1,-length_mm)
# Select all a range of contiguous varibles (common_name:length_mm)
select(df1, common_name:length_mm)
```

## Filter
Filter allows you to access observations based on specific criteria
```{r}
# Filter all observation where the variable common_name is Sockeye salmon
filter(df1, common_name == 'Sockeye salmon')
# Filter all observations where the variable common_name is either Sockeye salmon or Chinook Salmon
filter(df1, common_name %in% c('Sockeye salmon', 'Chinook salmon'))
# Filter all observations where the variable common_name ends with 'salmon'. To do this we use stringr function str_ends recognise strings that end with 'salmon'.
filter(df1, str_ends(common_name, 'salmon'))
# Filter all observations where the variable length_mm is greater than 200 or less than 120
filter(df1, length_mm > 200 | length_mm < 120)
```

## Arrange
Arrange sorts the dataframe based on a specific variable or variables
```{r}
# Arrange the data based on the variable length_mm
arrange(df1, length_mm)
# Arrange the data first based on the variable common_name, then secondly absed on length_mm in a descending order.
arrange(df1, common_name, desc(length_mm))
```

## Mutate
Mutate creates a new variable based on some form of computation
```{r}
# A new variable is created based on the caluclation of the z-score of the variable IGF1_ng_ml using scale()
mutate(df1, scale(IGF1_ng_ml, center = TRUE, scale = TRUE))
# A new variable is created called IGFngml_zscore, based on the caluclation of the z-score of the variable IGF1_ng_ml using scale()
mutate(df1, IGFngml_zscore = scale(IGF1_ng_ml, center = TRUE, scale = TRUE))
```

## Summarize
Summarize applies aggregating or summary function to a group
```{r}
# First we define the common_name as a group. 
df1_byname <- group_by(df1, common_name)
# Summarise is used to count over the grouped common_names
summarise(df1_byname, count = n())
# Summarise is used to calculate mean IGF1_ng_ml over the grouped common_names
summarise(df1_byname, IGF1_ng_ml_ave = mean(IGF1_ng_ml, na.rm = T))
```

## Group
Grouping can also help ask questions with other functions
```{r}
# Filter obsevrations with the 2 smallest length_mm for each grouped common_names
filter(df1_byname, rank(length_mm) <= 2)

# Filter obsevrations with at least 5 for each grouped common_names
filter(df1_byname, n() > 5)

# A new variable is created using z-score within the grouped common_names
mutate(df1_byname, IGFngml_zscore = scale(IGF1_ng_ml, center = TRUE, scale = TRUE))

```

# Piping (%>%): A way to string together functions together
Piping allows you to pass the result from one expression directly into another.

 -> same graphic as before , but extend
 https://github.com/trinker/tidyr_in_a_nutshell

## Piping versus not piping
```{r}
# Without pipe
df1_byname <- group_by(df1, common_name)
summarise(df1_byname, IGF1_ng_ml_ave=mean(IGF1_ng_ml, na.rm=T))

# With pipe
group_by(df1, common_name) %>% summarise(IGF1_ng_ml_ave=mean(IGF1_ng_ml, na.rm=T))
```

## Building pipes together
```{r}
group_by(df1, common_name) %>% 
  filter(length_mm > 200) %>% 
  summarise(IGF1_ng_ml_ave = mean(IGF1_ng_ml, na.rm = T))

mutate(df1, size = if_else(length_mm > 200, 'big_fish', 'small_fish')) %>% 
  group_by(common_name, size) %>% 
  filter() %>% 
  summarise(IGF1_ng_ml_ave = mean(IGF1_ng_ml, na.rm = T))

mutate(df1, size = if_else(length_mm > 200, 'big_fish', 'small_fish')) %>% 
  group_by(common_name, size) %>% 
  filter() %>% 
  summarise(IGF1_ng_ml_ave = mean(IGF1_ng_ml, na.rm = T)) %>%
  filter(common_name != 'Coho salmon')  %>%
  filter(common_name !='Sockeye salmon')
```

## Say want to graph what is going on with these fish? age species. IGF per length. 
```{r, warning=F, message=F}
library(plotly)

p<-mutate(df1,size=if_else(length_mm>200, 'big_fish', 'small_fish')) %>% group_by(common_name, size) %>% filter() %>% summarise(IGF1_ng_ml_ave=mean(IGF1_ng_ml, na.rm=T)) %>% filter(common_name!='Coho salmon')  %>% filter(common_name!='Sockeye salmon') %>% ggplot( aes(x = common_name, y = IGF1_ng_ml_ave, group = size, fill = size)) + geom_bar(stat = "identity", position = "dodge") + theme(axis.text.x = element_text(angle = 90))

ggplotly(p)
```

CHALLENGE
```{r}
# GET A SPECIFIC GROUP AND PLOT IT. 
```

ANSWER
```{r}
# GET A SPECIIFC GROUP AND PLOT IT. 
```


## So we blasted through what being tidy can give you. So how we do get tidy? Reading the data in and making tibbles.
Now lets tidy some data. We know how to work a little bit with some data. 

ReadR:
read_csv(): comma separated (CSV) files
read_tsv(): tab separated files
read_delim(): general delimited files
read_fwf(): fixed width files
read_table(): tabular files where columns are separated by white-space.
read_log(): web log files

```{r}


#Base gives you everything
untidy_counts_base <- read.csv("~/Documents/Box Sync/RU/Teaching/teaching/tidyR/dataset/hemato_rnaseq_counts.csv")

#readr gives you a tibble
untidy_counts <- read_csv("~/Documents/Box Sync/RU/Teaching/teaching/tidyR/dataset/hemato_rnaseq_counts.csv")
untidy_counts <- read_csv("~/Documents/Box Sync/RU/Teaching/teaching/tidyR/dataset/hemato_rnaseq_counts.csv", col_types = cols(
    ENTREZ = col_character(),
    CD34_1 = col_integer(),
    ORTHO_1 = col_integer(),
    CD34_2 = col_integer(),
    ORTHO_2 = col_integer()
  ))

```

#subsetting tibbles

```{r}
untidy_counts[,1]
untidy_counts[1,]
untidy_counts[1]

untidy_counts[[1]]
untidy_counts$ENTREZ
```

#Converting Tibbles - Back and Forth
```{r}
as_tibble(untidy_counts_base)
untidy_counts_base<-as_tibble(untidy_counts_base) %>% mutate_at(vars(ENTREZ), as.character)
untidy_counts_base

as.data.frame(untidy_counts_base)
```

# Make your own tibble. Lets grab some metadata 
```{r}
library(org.Hs.eg.db)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)

keys<-untidy_counts$ENTREZ
symbols<-select(org.Hs.eg.db, keys=keys,columns="SYMBOL", keytype="ENTREZID")
chrs<-select(TxDb.Hsapiens.UCSC.hg19.knownGene, keys=keys, columns="TXCHROM", keytype="GENEID")

geneExons <- exonsBy(TxDb.Hsapiens.UCSC.hg19.knownGene,by="gene")[keys]
txsLength<-sapply(geneExons, function(x){x %>% reduce() %>% width() %>% sum()})

counts_metadata<-tibble(ID=symbols$ENTREZID,SYMBOL=symbols$SYMBOL,CHR=chrs$TXCHROM,LENGTH=txsLength)

```

# What is wrong with this dataframe from a tidy viewpoint?

* Each variable has its own column
* Each observation has its own row
* Each value has its own cell

```{r}
untidy_counts
```

A single variable with multiple columns

# How do we get tidy? - Pivot tools (formerly known as gather/spread )
```{r}
tidier_counts<-pivot_longer(untidy_counts, cols=c(-ENTREZ), names_to = c("Sample"), values_to = "counts")
   
pivot_wider(tidier_counts, names_from = c("Sample"), values_from = "counts")
```

# What next?
```{r}
tidier_counts
```

# Multiple variables in a single column

How do we get tidy? - Cleaning up
```{r}
tidy_counts<-separate(tidier_counts, Sample, sep="_", into=c("CellType","Rep"), remove=FALSE)
#UNITE IS ALSO A THING


#rememebr you can alawys pipe this all together as well
untidy_counts %>% pivot_longer(cols=c(-ENTREZ), names_to = c("Sample"), values_to = "counts") %>% separate(Sample, sep="_", into=c("CellType","Rep"), remove=FALSE)
```

# So now we have two related tidy data frames. Can we put them together?

You need a key. Often we want this to be unique i.e. ENTREZ ID. 

```{r}

inner_join(tidy_counts,counts_metadata, by = c("ENTREZ" = "ID"))

```

## There are many ways to join things

Inner Join 
* Keeps all observations in x and y with matching keys

Outer Join
* A left join keeps all observations in x and those in y with matching keys.
* A right join keeps all observations in y and those in x with matching keys. 
* A full join keeps all observations in x and y

## Example - I only want to look at expressed genes

```{r}
expressed_genes<-tidy_counts %>% group_by(ENTREZ) %>% summarise(count_total=sum(counts)) %>% filter(count_total>0)

left_join(tidy_counts,expressed_genes, by = c("ENTREZ" = "ENTREZ")) %>% print(n=20)
tidy_counts_expressed<-right_join(tidy_counts,expressed_genes, by = c("ENTREZ" = "ENTREZ"))
tidy_counts_expressed  %>% print(n=20)
```


## Example - I only want to look at expressed genes
```{r}
# Filtering joins

```

## Calculate CPMs and TPMs

Show diagram of the math

```{r}
tidy_counts_expressed <- tidy_counts_expressed  %>% group_by(Sample) %>% mutate(CPM=(counts/sum(counts))*1000000)

tidy_counts_expressed <- tidy_counts_expressed %>% inner_join(counts_metadata, by = c("ENTREZ" = "ID")) %>%  mutate(TPM=(counts/(LENGTH/1000))/(sum(counts)/1000000))


p <- tidy_counts_expressed %>% ggplot(aes(x=CPM, y=TPM)) +geom_point() + scale_x_continuous(name="log2(CPM)",trans='log2') + scale_y_continuous(name="log2(TPM)",trans='log2') 

ggplotly(p)
```

writing out
```{r}
# write_csv etc

```


# At this point we have covered the most essential facets of tidy
~~readr – reading data into R~~
~~dplyr – mainpulating data~~
~~tibble - working with tibbles~~
~~tidyr – miscellaneous tools for tidying data~~
ggplot2 – making pretty graphs
stringr – working with strings
purr - iterating over data
forcats - working with factors

#stringr

Character manipulation: these functions allow you to manipulate individual characters within the strings in character vectors.

Whitespace tools to add, remove, and manipulate whitespace.

Locale sensitive operations whose operations will vary from locale to locale.

Pattern matching functions. These recognise four engines of pattern description. The most common is regular expressions, but there are three other tools.

#purr

applying functions to datasets

# tidy history and ethos

Hadley Wickham (Chief Scientist at RStudio) has been the driving force behind the tidyverse. It now serves as the basis for many R packages and functions. 

There is a lot of support at https://www.tidyverse.org/

Hadley also wrote a paper about why tidy data is best: www.jstatsoft.org/v59/i10/paper.




## BRC outro
```{r}

```







